/*
  File autogenerated by gengetopt version 2.22.4
  generated with the following command:
  gengetopt --conf-parser -i options.ggo 

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif

#include <getopt.h>

#include "cmdline.h"

const char *gengetopt_args_info_purpose = "This software simulates hopping in disordered semiconductors with hopping on \nlocalized states. It uses Monte-Carlo simulation techniques. See the README \nfile to learn more.";

const char *gengetopt_args_info_usage = "Usage: hop [OPTIONS]...";

const char *gengetopt_args_info_description = "";

const char *gengetopt_args_info_help[] = {
  "  -h, --help                    Print help and exit",
  "  -V, --version                 Print version and exit",
  "  -l, --length=INT              This parameter specifies the length of the \n                                  (cubic) sample. If it parameter is set, the \n                                  options X,Y,Z are ignored!",
  "  -X, --X=INT                   The x-length of the sample. Right now, only \n                                  cubic samples should be used, so rather use \n                                  the parameter --length.  (default=`50')",
  "  -Y, --Y=INT                   The y-length of the sample. Right now, only \n                                  cubic samples should be used, so rather use \n                                  the parameter --length.  (default=`50')",
  "  -Z, --Z=INT                   The z-length of the sample. Right now, only \n                                  cubic samples should be used, so rather use \n                                  the parameter --length.  (default=`50')",
  "  -n, --ncarriers=INT           The number of charge carriers in the system.  \n                                  (default=`10')",
  "  -N, --nsites=INT              The number of localized states. This value has \n                                  to be bigger than --ncarriers. Deprecated! \n                                  Scale the number os states using --length.  \n                                  (default=`125000')",
  "  -s, --sigma=FLOAT             The width of the DOS specified with --exponent. \n                                   (default=`1.0')",
  "  -p, --exponent=FLOAT          The exponent of the DOS g(x) = \n                                  exp(-(x/sigma)^p)  (default=`2.0')",
  "  -a, --llength=FLOAT           Localization length of the sites, assumed equal \n                                  for all of them.  (default=`0.215')",
  "  -r, --rc=FLOAT                Determines up to which distance sites should be \n                                  neighbors.  (default=`3')",
  "      --rseed=LONG              Set the random seed manually.",
  "  -F, --field=FLOAT             The electric field strength in z-direction.  \n                                  (default=`0.3')",
  "  -T, --temperature=FLOAT       The temperature of the simulation.  \n                                  (default=`0.3')",
  "      --gaussian                Use a Gaussian DOS with std. dev. sigma. g(x) = \n                                  exp(-1/2*(x/sigma)^2)  (default=off)",
  "      --ar                      Use Walker's random number generation and the \n                                  accept/reject technique for finding the next \n                                  transition. This is efficient for high \n                                  concentrations around n=N/2  (default=off)",
  "\n",
  "  -I, --simulation=LONG         The number of hops during which statistics are \n                                  collected.  (default=`1000000000')",
  "  -R, --relaxation=LONG         The number of hops to relax.  \n                                  (default=`100000000')",
  "      --removesoftpairs         Remove softpairs.  (default=off)",
  "      --softpairthreshold=FLOAT The min hopping rate ratio to define a softpair \n                                   (default=`0.95')",
  "  -i, --nruns=INT               The number of runs to average over.  \n                                  (default=`1')",
  "  -P, --parallel                If the runs given with the --nruns option \n                                  should be executed using mutliple cores and \n                                  parallelization. This suppresses any progress \n                                  output of the runs but will be very fast on \n                                  multicore systems.  (default=off)",
  "\n",
  "  -q, --quiet                   Don't say anything.  (default=off)",
  "  -o, --outputfolder=STRING     The name of the output folder if one wants \n                                  output files.",
  "      --transitions             Save all transitions to a file. (Can be big, \n                                  scales with -l^3!) Only valid when \n                                  --outputfolder is given  (default=off)",
  "      --summary=STRING          The name of the summary file to which one \n                                  summary result line is then written.",
  "      --comment=STRING          Specify a string that is appended to the line \n                                  in the summary file for better overview over \n                                  the simulated data.",
  "  -f, --conf_file=STRING        Location of a configuration file for the \n                                  simulation.",
  "      --memreq                  Estimates the used memory for the specified \n                                  parameter set. Print's the information and \n                                  exits immediately  (default=off)",
    0
};

typedef enum {ARG_NO
  , ARG_FLAG
  , ARG_STRING
  , ARG_INT
  , ARG_LONG
  , ARG_FLOAT
} cmdline_parser_arg_type;

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error);

struct line_list
{
  char * string_arg;
  struct line_list * next;
};

static struct line_list *cmd_line_list = 0;
static struct line_list *cmd_line_list_tmp = 0;

static void
free_cmd_list(void)
{
  /* free the list of a previous call */
  if (cmd_line_list)
    {
      while (cmd_line_list) {
        cmd_line_list_tmp = cmd_line_list;
        cmd_line_list = cmd_line_list->next;
        free (cmd_line_list_tmp->string_arg);
        free (cmd_line_list_tmp);
      }
    }
}


static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->length_given = 0 ;
  args_info->X_given = 0 ;
  args_info->Y_given = 0 ;
  args_info->Z_given = 0 ;
  args_info->ncarriers_given = 0 ;
  args_info->nsites_given = 0 ;
  args_info->sigma_given = 0 ;
  args_info->exponent_given = 0 ;
  args_info->llength_given = 0 ;
  args_info->rc_given = 0 ;
  args_info->rseed_given = 0 ;
  args_info->field_given = 0 ;
  args_info->temperature_given = 0 ;
  args_info->gaussian_given = 0 ;
  args_info->ar_given = 0 ;
  args_info->simulation_given = 0 ;
  args_info->relaxation_given = 0 ;
  args_info->removesoftpairs_given = 0 ;
  args_info->softpairthreshold_given = 0 ;
  args_info->nruns_given = 0 ;
  args_info->parallel_given = 0 ;
  args_info->quiet_given = 0 ;
  args_info->outputfolder_given = 0 ;
  args_info->transitions_given = 0 ;
  args_info->summary_given = 0 ;
  args_info->comment_given = 0 ;
  args_info->conf_file_given = 0 ;
  args_info->memreq_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  FIX_UNUSED (args_info);
  args_info->length_orig = NULL;
  args_info->X_arg = 50;
  args_info->X_orig = NULL;
  args_info->Y_arg = 50;
  args_info->Y_orig = NULL;
  args_info->Z_arg = 50;
  args_info->Z_orig = NULL;
  args_info->ncarriers_arg = 10;
  args_info->ncarriers_orig = NULL;
  args_info->nsites_arg = 125000;
  args_info->nsites_orig = NULL;
  args_info->sigma_arg = 1.0;
  args_info->sigma_orig = NULL;
  args_info->exponent_arg = 2.0;
  args_info->exponent_orig = NULL;
  args_info->llength_arg = 0.215;
  args_info->llength_orig = NULL;
  args_info->rc_arg = 3;
  args_info->rc_orig = NULL;
  args_info->rseed_orig = NULL;
  args_info->field_arg = 0.3;
  args_info->field_orig = NULL;
  args_info->temperature_arg = 0.3;
  args_info->temperature_orig = NULL;
  args_info->gaussian_flag = 0;
  args_info->ar_flag = 0;
  args_info->simulation_arg = 1000000000;
  args_info->simulation_orig = NULL;
  args_info->relaxation_arg = 100000000;
  args_info->relaxation_orig = NULL;
  args_info->removesoftpairs_flag = 0;
  args_info->softpairthreshold_arg = 0.95;
  args_info->softpairthreshold_orig = NULL;
  args_info->nruns_arg = 1;
  args_info->nruns_orig = NULL;
  args_info->parallel_flag = 0;
  args_info->quiet_flag = 0;
  args_info->outputfolder_arg = NULL;
  args_info->outputfolder_orig = NULL;
  args_info->transitions_flag = 0;
  args_info->summary_arg = NULL;
  args_info->summary_orig = NULL;
  args_info->comment_arg = NULL;
  args_info->comment_orig = NULL;
  args_info->conf_file_arg = NULL;
  args_info->conf_file_orig = NULL;
  args_info->memreq_flag = 0;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{


  args_info->help_help = gengetopt_args_info_help[0] ;
  args_info->version_help = gengetopt_args_info_help[1] ;
  args_info->length_help = gengetopt_args_info_help[2] ;
  args_info->X_help = gengetopt_args_info_help[3] ;
  args_info->Y_help = gengetopt_args_info_help[4] ;
  args_info->Z_help = gengetopt_args_info_help[5] ;
  args_info->ncarriers_help = gengetopt_args_info_help[6] ;
  args_info->nsites_help = gengetopt_args_info_help[7] ;
  args_info->sigma_help = gengetopt_args_info_help[8] ;
  args_info->exponent_help = gengetopt_args_info_help[9] ;
  args_info->llength_help = gengetopt_args_info_help[10] ;
  args_info->rc_help = gengetopt_args_info_help[11] ;
  args_info->rseed_help = gengetopt_args_info_help[12] ;
  args_info->field_help = gengetopt_args_info_help[13] ;
  args_info->temperature_help = gengetopt_args_info_help[14] ;
  args_info->gaussian_help = gengetopt_args_info_help[15] ;
  args_info->ar_help = gengetopt_args_info_help[16] ;
  args_info->simulation_help = gengetopt_args_info_help[18] ;
  args_info->relaxation_help = gengetopt_args_info_help[19] ;
  args_info->removesoftpairs_help = gengetopt_args_info_help[20] ;
  args_info->softpairthreshold_help = gengetopt_args_info_help[21] ;
  args_info->nruns_help = gengetopt_args_info_help[22] ;
  args_info->parallel_help = gengetopt_args_info_help[23] ;
  args_info->quiet_help = gengetopt_args_info_help[25] ;
  args_info->outputfolder_help = gengetopt_args_info_help[26] ;
  args_info->transitions_help = gengetopt_args_info_help[27] ;
  args_info->summary_help = gengetopt_args_info_help[28] ;
  args_info->comment_help = gengetopt_args_info_help[29] ;
  args_info->conf_file_help = gengetopt_args_info_help[30] ;
  args_info->memreq_help = gengetopt_args_info_help[31] ;
  
}

void
cmdline_parser_print_version (void)
{
  printf ("%s %s\n",
     (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),
     CMDLINE_PARSER_VERSION);
}

static void print_help_common(void) {
  cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  if (strlen(gengetopt_args_info_usage) > 0)
    printf("\n%s\n", gengetopt_args_info_usage);

  printf("\n");

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n\n", gengetopt_args_info_description);
}

void
cmdline_parser_print_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);
}

void
cmdline_parser_params_init(struct cmdline_parser_params *params)
{
  if (params)
    { 
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}

struct cmdline_parser_params *
cmdline_parser_params_create(void)
{
  struct cmdline_parser_params *params = 
    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));
  cmdline_parser_params_init(params);  
  return params;
}

static void
free_string_field (char **s)
{
  if (*s)
    {
      free (*s);
      *s = 0;
    }
}


static void
cmdline_parser_release (struct gengetopt_args_info *args_info)
{

  free_string_field (&(args_info->length_orig));
  free_string_field (&(args_info->X_orig));
  free_string_field (&(args_info->Y_orig));
  free_string_field (&(args_info->Z_orig));
  free_string_field (&(args_info->ncarriers_orig));
  free_string_field (&(args_info->nsites_orig));
  free_string_field (&(args_info->sigma_orig));
  free_string_field (&(args_info->exponent_orig));
  free_string_field (&(args_info->llength_orig));
  free_string_field (&(args_info->rc_orig));
  free_string_field (&(args_info->rseed_orig));
  free_string_field (&(args_info->field_orig));
  free_string_field (&(args_info->temperature_orig));
  free_string_field (&(args_info->simulation_orig));
  free_string_field (&(args_info->relaxation_orig));
  free_string_field (&(args_info->softpairthreshold_orig));
  free_string_field (&(args_info->nruns_orig));
  free_string_field (&(args_info->outputfolder_arg));
  free_string_field (&(args_info->outputfolder_orig));
  free_string_field (&(args_info->summary_arg));
  free_string_field (&(args_info->summary_orig));
  free_string_field (&(args_info->comment_arg));
  free_string_field (&(args_info->comment_orig));
  free_string_field (&(args_info->conf_file_arg));
  free_string_field (&(args_info->conf_file_orig));
  
  

  clear_given (args_info);
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
{
  FIX_UNUSED (values);
  if (arg) {
    fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}


int
cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
{
  int i = 0;

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot dump options to stream\n", CMDLINE_PARSER_PACKAGE);
      return EXIT_FAILURE;
    }

  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0 );
  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0 );
  if (args_info->length_given)
    write_into_file(outfile, "length", args_info->length_orig, 0);
  if (args_info->X_given)
    write_into_file(outfile, "X", args_info->X_orig, 0);
  if (args_info->Y_given)
    write_into_file(outfile, "Y", args_info->Y_orig, 0);
  if (args_info->Z_given)
    write_into_file(outfile, "Z", args_info->Z_orig, 0);
  if (args_info->ncarriers_given)
    write_into_file(outfile, "ncarriers", args_info->ncarriers_orig, 0);
  if (args_info->nsites_given)
    write_into_file(outfile, "nsites", args_info->nsites_orig, 0);
  if (args_info->sigma_given)
    write_into_file(outfile, "sigma", args_info->sigma_orig, 0);
  if (args_info->exponent_given)
    write_into_file(outfile, "exponent", args_info->exponent_orig, 0);
  if (args_info->llength_given)
    write_into_file(outfile, "llength", args_info->llength_orig, 0);
  if (args_info->rc_given)
    write_into_file(outfile, "rc", args_info->rc_orig, 0);
  if (args_info->rseed_given)
    write_into_file(outfile, "rseed", args_info->rseed_orig, 0);
  if (args_info->field_given)
    write_into_file(outfile, "field", args_info->field_orig, 0);
  if (args_info->temperature_given)
    write_into_file(outfile, "temperature", args_info->temperature_orig, 0);
  if (args_info->gaussian_given)
    write_into_file(outfile, "gaussian", 0, 0 );
  if (args_info->ar_given)
    write_into_file(outfile, "ar", 0, 0 );
  if (args_info->simulation_given)
    write_into_file(outfile, "simulation", args_info->simulation_orig, 0);
  if (args_info->relaxation_given)
    write_into_file(outfile, "relaxation", args_info->relaxation_orig, 0);
  if (args_info->removesoftpairs_given)
    write_into_file(outfile, "removesoftpairs", 0, 0 );
  if (args_info->softpairthreshold_given)
    write_into_file(outfile, "softpairthreshold", args_info->softpairthreshold_orig, 0);
  if (args_info->nruns_given)
    write_into_file(outfile, "nruns", args_info->nruns_orig, 0);
  if (args_info->parallel_given)
    write_into_file(outfile, "parallel", 0, 0 );
  if (args_info->quiet_given)
    write_into_file(outfile, "quiet", 0, 0 );
  if (args_info->outputfolder_given)
    write_into_file(outfile, "outputfolder", args_info->outputfolder_orig, 0);
  if (args_info->transitions_given)
    write_into_file(outfile, "transitions", 0, 0 );
  if (args_info->summary_given)
    write_into_file(outfile, "summary", args_info->summary_orig, 0);
  if (args_info->comment_given)
    write_into_file(outfile, "comment", args_info->comment_orig, 0);
  if (args_info->conf_file_given)
    write_into_file(outfile, "conf_file", args_info->conf_file_orig, 0);
  if (args_info->memreq_given)
    write_into_file(outfile, "memreq", 0, 0 );
  

  i = EXIT_SUCCESS;
  return i;
}

int
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  i = cmdline_parser_dump(outfile, args_info);
  fclose (outfile);

  return i;
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  cmdline_parser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = 0;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

int
cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
{
  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,
                   struct cmdline_parser_params *params)
{
  int result;
  result = cmdline_parser_internal (argc, argv, args_info, params, 0);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;
  struct cmdline_parser_params params;
  
  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = cmdline_parser_internal (argc, argv, args_info, &params, 0);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  FIX_UNUSED (args_info);
  FIX_UNUSED (prog_name);
  return EXIT_SUCCESS;
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see cmdline_parser_params.check_ambiguity
 * @param override @see cmdline_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
               unsigned int *field_given, unsigned int *prev_given, 
               char *value, const char *possible_values[],
               const char *default_value,
               cmdline_parser_arg_type arg_type,
               int check_ambiguity, int override,
               int no_free, int multiple_option,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  char *stop_char = 0;
  const char *val = value;
  int found;
  char **string_field;
  FIX_UNUSED (field);

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
               package_name, long_opt, short_opt,
               (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
               package_name, long_opt,
               (additional_error ? additional_error : ""));
      return 1; /* failure */
    }

  FIX_UNUSED (default_value);
    
  if (field_given && *field_given && ! override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch(arg_type) {
  case ARG_FLAG:
    *((int *)field) = !*((int *)field);
    break;
  case ARG_INT:
    if (val) *((int *)field) = strtol (val, &stop_char, 0);
    break;
  case ARG_LONG:
    if (val) *((long *)field) = (long)strtol (val, &stop_char, 0);
    break;
  case ARG_FLOAT:
    if (val) *((float *)field) = (float)strtod (val, &stop_char);
    break;
  case ARG_STRING:
    if (val) {
      string_field = (char **)field;
      if (!no_free && *string_field)
        free (*string_field); /* free previous string */
      *string_field = gengetopt_strdup (val);
    }
    break;
  default:
    break;
  };

  /* check numeric conversion */
  switch(arg_type) {
  case ARG_INT:
  case ARG_LONG:
  case ARG_FLOAT:
    if (val && !(stop_char && *stop_char == '\0')) {
      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
      return 1; /* failure */
    }
    break;
  default:
    ;
  };

  /* store the original value */
  switch(arg_type) {
  case ARG_NO:
  case ARG_FLAG:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free (*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup (value);
      }
    }
  };

  return 0; /* OK */
}


int
cmdline_parser_internal (
  int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error = 0;
  struct gengetopt_args_info local_args_info;
  
  int override;
  int initialize;
  int check_required;
  int check_ambiguity;
  
  package_name = argv[0];
  
  override = params->override;
  initialize = params->initialize;
  check_required = params->check_required;
  check_ambiguity = params->check_ambiguity;

  if (initialize)
    cmdline_parser_init (args_info);

  cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1)
    {
      int option_index = 0;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "version",	0, NULL, 'V' },
        { "length",	1, NULL, 'l' },
        { "X",	1, NULL, 'X' },
        { "Y",	1, NULL, 'Y' },
        { "Z",	1, NULL, 'Z' },
        { "ncarriers",	1, NULL, 'n' },
        { "nsites",	1, NULL, 'N' },
        { "sigma",	1, NULL, 's' },
        { "exponent",	1, NULL, 'p' },
        { "llength",	1, NULL, 'a' },
        { "rc",	1, NULL, 'r' },
        { "rseed",	1, NULL, 0 },
        { "field",	1, NULL, 'F' },
        { "temperature",	1, NULL, 'T' },
        { "gaussian",	0, NULL, 0 },
        { "ar",	0, NULL, 0 },
        { "simulation",	1, NULL, 'I' },
        { "relaxation",	1, NULL, 'R' },
        { "removesoftpairs",	0, NULL, 0 },
        { "softpairthreshold",	1, NULL, 0 },
        { "nruns",	1, NULL, 'i' },
        { "parallel",	0, NULL, 'P' },
        { "quiet",	0, NULL, 'q' },
        { "outputfolder",	1, NULL, 'o' },
        { "transitions",	0, NULL, 0 },
        { "summary",	1, NULL, 0 },
        { "comment",	1, NULL, 0 },
        { "conf_file",	1, NULL, 'f' },
        { "memreq",	0, NULL, 0 },
        { 0,  0, 0, 0 }
      };

      c = getopt_long (argc, argv, "hVl:X:Y:Z:n:N:s:p:a:r:F:T:I:R:i:Pqo:f:", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          cmdline_parser_print_help ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          cmdline_parser_print_version ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'l':	/* This parameter specifies the length of the (cubic) sample. If it parameter is set, the options X,Y,Z are ignored!.  */
        
        
          if (update_arg( (void *)&(args_info->length_arg), 
               &(args_info->length_orig), &(args_info->length_given),
              &(local_args_info.length_given), optarg, 0, 0, ARG_INT,
              check_ambiguity, override, 0, 0,
              "length", 'l',
              additional_error))
            goto failure;
        
          break;
        case 'X':	/* The x-length of the sample. Right now, only cubic samples should be used, so rather use the parameter --length..  */
        
        
          if (update_arg( (void *)&(args_info->X_arg), 
               &(args_info->X_orig), &(args_info->X_given),
              &(local_args_info.X_given), optarg, 0, "50", ARG_INT,
              check_ambiguity, override, 0, 0,
              "X", 'X',
              additional_error))
            goto failure;
        
          break;
        case 'Y':	/* The y-length of the sample. Right now, only cubic samples should be used, so rather use the parameter --length..  */
        
        
          if (update_arg( (void *)&(args_info->Y_arg), 
               &(args_info->Y_orig), &(args_info->Y_given),
              &(local_args_info.Y_given), optarg, 0, "50", ARG_INT,
              check_ambiguity, override, 0, 0,
              "Y", 'Y',
              additional_error))
            goto failure;
        
          break;
        case 'Z':	/* The z-length of the sample. Right now, only cubic samples should be used, so rather use the parameter --length..  */
        
        
          if (update_arg( (void *)&(args_info->Z_arg), 
               &(args_info->Z_orig), &(args_info->Z_given),
              &(local_args_info.Z_given), optarg, 0, "50", ARG_INT,
              check_ambiguity, override, 0, 0,
              "Z", 'Z',
              additional_error))
            goto failure;
        
          break;
        case 'n':	/* The number of charge carriers in the system..  */
        
        
          if (update_arg( (void *)&(args_info->ncarriers_arg), 
               &(args_info->ncarriers_orig), &(args_info->ncarriers_given),
              &(local_args_info.ncarriers_given), optarg, 0, "10", ARG_INT,
              check_ambiguity, override, 0, 0,
              "ncarriers", 'n',
              additional_error))
            goto failure;
        
          break;
        case 'N':	/* The number of localized states. This value has to be bigger than --ncarriers. Deprecated! Scale the number os states using --length..  */
        
        
          if (update_arg( (void *)&(args_info->nsites_arg), 
               &(args_info->nsites_orig), &(args_info->nsites_given),
              &(local_args_info.nsites_given), optarg, 0, "125000", ARG_INT,
              check_ambiguity, override, 0, 0,
              "nsites", 'N',
              additional_error))
            goto failure;
        
          break;
        case 's':	/* The width of the DOS specified with --exponent..  */
        
        
          if (update_arg( (void *)&(args_info->sigma_arg), 
               &(args_info->sigma_orig), &(args_info->sigma_given),
              &(local_args_info.sigma_given), optarg, 0, "1.0", ARG_FLOAT,
              check_ambiguity, override, 0, 0,
              "sigma", 's',
              additional_error))
            goto failure;
        
          break;
        case 'p':	/* The exponent of the DOS g(x) = exp(-(x/sigma)^p).  */
        
        
          if (update_arg( (void *)&(args_info->exponent_arg), 
               &(args_info->exponent_orig), &(args_info->exponent_given),
              &(local_args_info.exponent_given), optarg, 0, "2.0", ARG_FLOAT,
              check_ambiguity, override, 0, 0,
              "exponent", 'p',
              additional_error))
            goto failure;
        
          break;
        case 'a':	/* Localization length of the sites, assumed equal for all of them..  */
        
        
          if (update_arg( (void *)&(args_info->llength_arg), 
               &(args_info->llength_orig), &(args_info->llength_given),
              &(local_args_info.llength_given), optarg, 0, "0.215", ARG_FLOAT,
              check_ambiguity, override, 0, 0,
              "llength", 'a',
              additional_error))
            goto failure;
        
          break;
        case 'r':	/* Determines up to which distance sites should be neighbors..  */
        
        
          if (update_arg( (void *)&(args_info->rc_arg), 
               &(args_info->rc_orig), &(args_info->rc_given),
              &(local_args_info.rc_given), optarg, 0, "3", ARG_FLOAT,
              check_ambiguity, override, 0, 0,
              "rc", 'r',
              additional_error))
            goto failure;
        
          break;
        case 'F':	/* The electric field strength in z-direction..  */
        
        
          if (update_arg( (void *)&(args_info->field_arg), 
               &(args_info->field_orig), &(args_info->field_given),
              &(local_args_info.field_given), optarg, 0, "0.3", ARG_FLOAT,
              check_ambiguity, override, 0, 0,
              "field", 'F',
              additional_error))
            goto failure;
        
          break;
        case 'T':	/* The temperature of the simulation..  */
        
        
          if (update_arg( (void *)&(args_info->temperature_arg), 
               &(args_info->temperature_orig), &(args_info->temperature_given),
              &(local_args_info.temperature_given), optarg, 0, "0.3", ARG_FLOAT,
              check_ambiguity, override, 0, 0,
              "temperature", 'T',
              additional_error))
            goto failure;
        
          break;
        case 'I':	/* The number of hops during which statistics are collected..  */
        
        
          if (update_arg( (void *)&(args_info->simulation_arg), 
               &(args_info->simulation_orig), &(args_info->simulation_given),
              &(local_args_info.simulation_given), optarg, 0, "1000000000", ARG_LONG,
              check_ambiguity, override, 0, 0,
              "simulation", 'I',
              additional_error))
            goto failure;
        
          break;
        case 'R':	/* The number of hops to relax..  */
        
        
          if (update_arg( (void *)&(args_info->relaxation_arg), 
               &(args_info->relaxation_orig), &(args_info->relaxation_given),
              &(local_args_info.relaxation_given), optarg, 0, "100000000", ARG_LONG,
              check_ambiguity, override, 0, 0,
              "relaxation", 'R',
              additional_error))
            goto failure;
        
          break;
        case 'i':	/* The number of runs to average over..  */
        
        
          if (update_arg( (void *)&(args_info->nruns_arg), 
               &(args_info->nruns_orig), &(args_info->nruns_given),
              &(local_args_info.nruns_given), optarg, 0, "1", ARG_INT,
              check_ambiguity, override, 0, 0,
              "nruns", 'i',
              additional_error))
            goto failure;
        
          break;
        case 'P':	/* If the runs given with the --nruns option should be executed using mutliple cores and parallelization. This suppresses any progress output of the runs but will be very fast on multicore systems..  */
        
        
          if (update_arg((void *)&(args_info->parallel_flag), 0, &(args_info->parallel_given),
              &(local_args_info.parallel_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "parallel", 'P',
              additional_error))
            goto failure;
        
          break;
        case 'q':	/* Don't say anything..  */
        
        
          if (update_arg((void *)&(args_info->quiet_flag), 0, &(args_info->quiet_given),
              &(local_args_info.quiet_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "quiet", 'q',
              additional_error))
            goto failure;
        
          break;
        case 'o':	/* The name of the output folder if one wants output files..  */
        
        
          if (update_arg( (void *)&(args_info->outputfolder_arg), 
               &(args_info->outputfolder_orig), &(args_info->outputfolder_given),
              &(local_args_info.outputfolder_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "outputfolder", 'o',
              additional_error))
            goto failure;
        
          break;
        case 'f':	/* Location of a configuration file for the simulation..  */
        
        
          if (update_arg( (void *)&(args_info->conf_file_arg), 
               &(args_info->conf_file_orig), &(args_info->conf_file_given),
              &(local_args_info.conf_file_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "conf_file", 'f',
              additional_error))
            goto failure;
        
          break;

        case 0:	/* Long option with no short option */
          /* Set the random seed manually..  */
          if (strcmp (long_options[option_index].name, "rseed") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->rseed_arg), 
                 &(args_info->rseed_orig), &(args_info->rseed_given),
                &(local_args_info.rseed_given), optarg, 0, 0, ARG_LONG,
                check_ambiguity, override, 0, 0,
                "rseed", '-',
                additional_error))
              goto failure;
          
          }
          /* Use a Gaussian DOS with std. dev. sigma. g(x) = exp(-1/2*(x/sigma)^2).  */
          else if (strcmp (long_options[option_index].name, "gaussian") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->gaussian_flag), 0, &(args_info->gaussian_given),
                &(local_args_info.gaussian_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "gaussian", '-',
                additional_error))
              goto failure;
          
          }
          /* Use Walker's random number generation and the accept/reject technique for finding the next transition. This is efficient for high concentrations around n=N/2.  */
          else if (strcmp (long_options[option_index].name, "ar") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->ar_flag), 0, &(args_info->ar_given),
                &(local_args_info.ar_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "ar", '-',
                additional_error))
              goto failure;
          
          }
          /* Remove softpairs..  */
          else if (strcmp (long_options[option_index].name, "removesoftpairs") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->removesoftpairs_flag), 0, &(args_info->removesoftpairs_given),
                &(local_args_info.removesoftpairs_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "removesoftpairs", '-',
                additional_error))
              goto failure;
          
          }
          /* The min hopping rate ratio to define a softpair.  */
          else if (strcmp (long_options[option_index].name, "softpairthreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->softpairthreshold_arg), 
                 &(args_info->softpairthreshold_orig), &(args_info->softpairthreshold_given),
                &(local_args_info.softpairthreshold_given), optarg, 0, "0.95", ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "softpairthreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Save all transitions to a file. (Can be big, scales with -l^3!) Only valid when --outputfolder is given.  */
          else if (strcmp (long_options[option_index].name, "transitions") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->transitions_flag), 0, &(args_info->transitions_given),
                &(local_args_info.transitions_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "transitions", '-',
                additional_error))
              goto failure;
          
          }
          /* The name of the summary file to which one summary result line is then written..  */
          else if (strcmp (long_options[option_index].name, "summary") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->summary_arg), 
                 &(args_info->summary_orig), &(args_info->summary_given),
                &(local_args_info.summary_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "summary", '-',
                additional_error))
              goto failure;
          
          }
          /* Specify a string that is appended to the line in the summary file for better overview over the simulated data..  */
          else if (strcmp (long_options[option_index].name, "comment") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->comment_arg), 
                 &(args_info->comment_orig), &(args_info->comment_given),
                &(local_args_info.comment_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "comment", '-',
                additional_error))
              goto failure;
          
          }
          /* Estimates the used memory for the specified parameter set. Print's the information and exits immediately.  */
          else if (strcmp (long_options[option_index].name, "memreq") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->memreq_flag), 0, &(args_info->memreq_given),
                &(local_args_info.memreq_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "memreq", '-',
                additional_error))
              goto failure;
          
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */




  cmdline_parser_release (&local_args_info);

  if ( error )
    return (EXIT_FAILURE);

  return 0;

failure:
  
  cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}

#ifndef CONFIG_FILE_LINE_SIZE
#define CONFIG_FILE_LINE_SIZE 2048
#endif
#define ADDITIONAL_ERROR " in configuration file "

#define CONFIG_FILE_LINE_BUFFER_SIZE (CONFIG_FILE_LINE_SIZE+3)
/* 3 is for "--" and "=" */

static int
_cmdline_parser_configfile (const char *filename, int *my_argc)
{
  FILE* file;
  char my_argv[CONFIG_FILE_LINE_BUFFER_SIZE+1];
  char linebuf[CONFIG_FILE_LINE_SIZE];
  int line_num = 0;
  int result = 0, equal;
  char *fopt, *farg;
  char *str_index;
  size_t len, next_token;
  char delimiter;

  if ((file = fopen(filename, "r")) == 0)
    {
      fprintf (stderr, "%s: Error opening configuration file '%s'\n",
               CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  while ((fgets(linebuf, CONFIG_FILE_LINE_SIZE, file)) != 0)
    {
      ++line_num;
      my_argv[0] = '\0';
      len = strlen(linebuf);
      if (len > (CONFIG_FILE_LINE_BUFFER_SIZE-1))
        {
          fprintf (stderr, "%s:%s:%d: Line too long in configuration file\n",
                   CMDLINE_PARSER_PACKAGE, filename, line_num);
          result = EXIT_FAILURE;
          break;
        }

      /* find first non-whitespace character in the line */
      next_token = strspn (linebuf, " \t\r\n");
      str_index  = linebuf + next_token;

      if ( str_index[0] == '\0' || str_index[0] == '#')
        continue; /* empty line or comment line is skipped */

      fopt = str_index;

      /* truncate fopt at the end of the first non-valid character */
      next_token = strcspn (fopt, " \t\r\n=");

      if (fopt[next_token] == '\0') /* the line is over */
        {
          farg  = 0;
          equal = 0;
          goto noarg;
        }

      /* remember if equal sign is present */
      equal = (fopt[next_token] == '=');
      fopt[next_token++] = '\0';

      /* advance pointers to the next token after the end of fopt */
      next_token += strspn (fopt + next_token, " \t\r\n");

      /* check for the presence of equal sign, and if so, skip it */
      if ( !equal )
        if ((equal = (fopt[next_token] == '=')))
          {
            next_token++;
            next_token += strspn (fopt + next_token, " \t\r\n");
          }
      str_index  += next_token;

      /* find argument */
      farg = str_index;
      if ( farg[0] == '\"' || farg[0] == '\'' )
        { /* quoted argument */
          str_index = strchr (++farg, str_index[0] ); /* skip opening quote */
          if (! str_index)
            {
              fprintf
                (stderr,
                 "%s:%s:%d: unterminated string in configuration file\n",
                 CMDLINE_PARSER_PACKAGE, filename, line_num);
              result = EXIT_FAILURE;
              break;
            }
        }
      else
        { /* read up the remaining part up to a delimiter */
          next_token = strcspn (farg, " \t\r\n#\'\"");
          str_index += next_token;
        }

      /* truncate farg at the delimiter and store it for further check */
      delimiter = *str_index, *str_index++ = '\0';

      /* everything but comment is illegal at the end of line */
      if (delimiter != '\0' && delimiter != '#')
        {
          str_index += strspn(str_index, " \t\r\n");
          if (*str_index != '\0' && *str_index != '#')
            {
              fprintf
                (stderr,
                 "%s:%s:%d: malformed string in configuration file\n",
                 CMDLINE_PARSER_PACKAGE, filename, line_num);
              result = EXIT_FAILURE;
              break;
            }
        }

    noarg:
      if (!strcmp(fopt,"include")) {
        if (farg && *farg) {
          result = _cmdline_parser_configfile(farg, my_argc);
        } else {
          fprintf(stderr, "%s:%s:%d: include requires a filename argument.\n",
                  CMDLINE_PARSER_PACKAGE, filename, line_num);
        }
        continue;
      }
      len = strlen(fopt);
      strcat (my_argv, len > 1 ? "--" : "-");
      strcat (my_argv, fopt);
      if (len > 1 && ((farg && *farg) || equal))
        strcat (my_argv, "=");
      if (farg && *farg)
        strcat (my_argv, farg);
      ++(*my_argc);

      cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));
      cmd_line_list_tmp->next = cmd_line_list;
      cmd_line_list = cmd_line_list_tmp;
      cmd_line_list->string_arg = gengetopt_strdup(my_argv);
    } /* while */

  if (file)
    fclose(file);
  return result;
}

int
cmdline_parser_configfile (
  const char *filename,
                           struct gengetopt_args_info *args_info,
                           int override, int initialize, int check_required)
{
  struct cmdline_parser_params params;

  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;
  
  return cmdline_parser_config_file (filename, args_info, &params);
}

int
cmdline_parser_config_file (const char *filename,
                           struct gengetopt_args_info *args_info,
                           struct cmdline_parser_params *params)
{
  int i, result;
  int my_argc = 1;
  char **my_argv_arg;
  char *additional_error;

  /* store the program name */
  cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));
  cmd_line_list_tmp->next = cmd_line_list;
  cmd_line_list = cmd_line_list_tmp;
  cmd_line_list->string_arg = gengetopt_strdup (CMDLINE_PARSER_PACKAGE);

  result = _cmdline_parser_configfile(filename, &my_argc);

  if (result != EXIT_FAILURE) {
    my_argv_arg = (char **) malloc((my_argc+1) * sizeof(char *));
    cmd_line_list_tmp = cmd_line_list;

    for (i = my_argc - 1; i >= 0; --i) {
      my_argv_arg[i] = cmd_line_list_tmp->string_arg;
      cmd_line_list_tmp = cmd_line_list_tmp->next;
    }

    my_argv_arg[my_argc] = 0;

    additional_error = (char *)malloc(strlen(filename) + strlen(ADDITIONAL_ERROR) + 1);
    strcpy (additional_error, ADDITIONAL_ERROR);
    strcat (additional_error, filename);
    result =
      cmdline_parser_internal (my_argc, my_argv_arg, args_info,
                              params,
                              additional_error);

    free (additional_error);
    free (my_argv_arg);
  }

  free_cmd_list();
  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}
